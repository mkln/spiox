# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Correlationc <- function(coordsx, coordsy, theta, matern, same) {
    .Call(`_spiox_Correlationc`, coordsx, coordsy, theta, matern, same)
}

dag_for_gridded_cols <- function(coords, m = 20L) {
    .Call(`_spiox_dag_for_gridded_cols`, coords, m)
}

daggp_build <- function(coords, dag, phi, sigmasq, nu, tausq, matern = 1L, num_threads = 1L, prune_dag = FALSE) {
    .Call(`_spiox_daggp_build`, coords, dag, phi, sigmasq, nu, tausq, matern, num_threads, prune_dag)
}

iox <- function(x, y, i, j, S, theta, matern = TRUE, diag_only = FALSE, at_limit = FALSE) {
    .Call(`_spiox_iox`, x, y, i, j, S, theta, matern, diag_only, at_limit)
}

#' @title Scaling factor of IOX.
#' @description This function computes the scaling factor used to compute the cross-covariance at zero distance for IOX.
#'
#' @param dag an object returned from `spiox::dag_vecchia` or similar
#' @param S a matrix of reference coordinates
#' @param theta a matrix of dimension (4,q) where each column are the marginal covariance parameters of the corresponding variable
#' @param matern an integer. Options are 0: power exponential, 1: matern, 2: wave
#' @param n_threads integer number of threads for multi-threaded operations
#'
#' @return A matrix of dimension (q,q) filled in its lower-triangular portion. The (i,j) element is the scaling factor for \eqn{C_{ij}}.
#' The IOX cross-covariance at zero distance will be \eqn{Sigma_{ij}} multiplied by this scaling factor.
#'
#' @details The function is designed for computing the IOX scaling factor used to compute the cross-covariances \eqn{C_{ij}}.
#'
#' @export
sfact <- function(dag, S, theta, matern = 1L, n_threads = 1L) {
    .Call(`_spiox_sfact`, dag, S, theta, matern, n_threads)
}

make_ix <- function(q, n) {
    .Call(`_spiox_make_ix`, q, n)
}

iox_mat <- function(x, y, S, theta, matern = TRUE, D_only = FALSE) {
    .Call(`_spiox_iox_mat`, x, y, S, theta, matern, D_only)
}

MaxMincpp <- function(locations) {
    .Call(`_spiox_MaxMincpp`, locations)
}

S_to_Sigma <- function(S) {
    .Call(`_spiox_S_to_Sigma`, S)
}

S_to_Q <- function(S) {
    .Call(`_spiox_S_to_Q`, S)
}

Sigma_to_correl <- function(Sigma) {
    .Call(`_spiox_Sigma_to_correl`, Sigma)
}

Sigma_identify <- function(Sigma, theta) {
    .Call(`_spiox_Sigma_identify`, Sigma, theta)
}

#' @title Spatial Response Model using Gaussian Processes with IOX.
#' @description This function performs Bayesian inference for a spatial response model using a 
#' multivariate GP with Inside-Out Cross-Covariance (IOX). 
#'
#' @param Y A numeric matrix (\eqn{n \times q}) of observed multivariate spatial responses, 
#' where \eqn{n} is the number of spatial locations and \eqn{q} is the number of response variables. 
#' @param X A numeric matrix (\eqn{n \times p}) of predictors corresponding to the observed responses.
#' @param coords A numeric matrix (\eqn{n \times d}) of spatial coordinates, where \eqn{d} is the spatial dimension 
#' (e.g., 2 for latitude and longitude).
#' @param custom_dag An object returned from `spiox::dag_vecchia` 
#' @param theta_opts A numeric matrix specifying options for the correlation parameters (\eqn{\theta}) 
#' used during MCMC updates. The way this is input determines how MCMC works. See details below.
#' @param Sigma_start A numeric matrix (\eqn{q \times q}) specifying the starting value for the IOX covariance matrix 
#' \eqn{\Sigma}.
#' @param Beta_start A numeric matrix (\eqn{p \times q}) specifying the starting values for the regression coefficients.
#' @param mcmc An integer specifying the number of MCMC iterations to perform. 
#' @param print_every An integer specifying the frequency of progress updates during MCMC iterations. Default is 100.
#' @param matern An integer flag for enabling Matérn correlation functions for spatial dependence modeling. Default is 1.
#' Other options: 0=power exponential, 2=wave.
#' @param sample_sigma A logical value indicating whether to sample the covariance matrix (\eqn{\Sigma}) 
#' via Gibbs update from an Inverse Wishart prior. Default is TRUE. 
#' @param sample_beta A logical value indicating whether to sample multivariate regression coefficients 
#' via Gibbs update from a Normal prior. Default is TRUE.
#' @param update_theta A logical value indicating whether to update the correlation parameter options (\eqn{\theta}) 
#' adaptively during MCMC iterations. This should be set to TRUE to run "IOX Full" or "IOX Cluster" from the paper, otherwise FALSE.
#' The update is performed jointly for the whole vector if q=3 or less; conditionally in blocks if q>3.
#' @param num_threads An integer specifying the number of threads for parallel computation. Default is 1.
#'
#' @return A list containing:
#' \item{Beta}{Array of dimension (p,q,mcmc) with posterior samples of the regression coefficients (\eqn{\beta}).}
#' \item{Sigma}{Array of dimension (q,q,mcmc) with posterior samples of the covariance matrix (\eqn{\Sigma}).}
#' \item{theta}{Array of dimension (4,q,mcmc) with posterior samples of the correlation parameters (\eqn{\theta}).}
#' \item{theta_which}{Cluster membership for "IOX Grid" and "IOX Cluster".}
#' \item{theta_opts}{Cluster options for "IOX Grid" and "IOX Cluster".}
#' \item{timings}{Breakdown of timings of the various MCMC operations (debugging).}
#'
#' @details The function is designed for scalable inference on spatial multivariate data using GP-IOX. 
#' Use multi-threading (`num_threads > 1`) for faster computation on large datasets.
#' How to set up `theta_opts`. Each column of theta has 4 elements. 1=phi, spatial decay parameter. 2=spatial variance. 3=smoothness or exponent. 4=nugget.
#' MCMC will sample the jth parameter a posteriori (j=1,2,3,4) ONLY if `var(theta_opts[j,])>0`. 
#' In other words, posterior sampling is DISABLED for parameter j if the entire jth row of `theta_opts` is set to the same value (which will be the fixed value of that parameter).
#' for "IOX Full", `theta_opts` should have \eqn{q} columns. For "IOX Cluster", `theta_opts` should have as many columns as the number of clusters (choose it smaller than \eqn{q}).
#' For "IOX Grid", `theta_opts` should have as many columns as the number of elements in the grid. Tested with up to 200 columns.
#' Beware that each column corresponds to a Vecchia-GP with `m` neighbors, so the memory footprint increases linearly with the number of columns of `theta_opts`.
#'
#' @export
spiox_response <- function(Y, X, coords, custom_dag, theta_opts, Sigma_start, Beta_start, mcmc = 1000L, print_every = 100L, matern = 1L, dag_opts = 0L, sample_sigma = TRUE, sample_beta = TRUE, update_theta = FALSE, num_threads = 1L) {
    .Call(`_spiox_spiox_response`, Y, X, coords, custom_dag, theta_opts, Sigma_start, Beta_start, mcmc, print_every, matern, dag_opts, sample_sigma, sample_beta, update_theta, num_threads)
}

#' @title Spatial Latent Model using Gaussian Processes with IOX as prior for latent effects.
#' @description This function performs Bayesian inference for a spatial latent model using a 
#' multivariate GP with Inside-Out Cross-Covariance (IOX) prior for the latent effects. 
#'
#' @param Y A numeric matrix (\eqn{n \times q}) of observed multivariate spatial responses, 
#' where \eqn{n} is the number of spatial locations and \eqn{q} is the number of response variables. 
#' @param X A numeric matrix (\eqn{n \times p}) of predictors corresponding to the observed responses.
#' @param coords A numeric matrix (\eqn{n \times d}) of spatial coordinates, where \eqn{d} is the spatial dimension 
#' (e.g., 2 for latitude and longitude).
#' @param custom_dag An object returned from `spiox::dag_vecchia` 
#' @param theta_opts A numeric matrix specifying options for the correlation parameters (\eqn{\theta}) 
#' used during MCMC updates. The way this is input determines how MCMC works. See details below.
#' @param Sigma_start A numeric matrix (\eqn{q \times q}) specifying the starting value for the IOX covariance matrix 
#' \eqn{\Sigma}.
#' @param Beta_start A numeric matrix (\eqn{p \times q}) specifying the starting values for the regression coefficients.
#' @param mcmc An integer specifying the number of MCMC iterations to perform. 
#' @param print_every An integer specifying the frequency of progress updates during MCMC iterations. Default is 100.
#' @param matern An integer flag for enabling Matérn correlation functions for spatial dependence modeling. Default is 1.
#' Other options: 0=power exponential, 2=wave.
#' @param sample_sigma A logical value indicating whether to sample the covariance matrix (\eqn{\Sigma}) 
#' via Gibbs update from an Inverse Wishart prior. Default is TRUE. 
#' @param sample_beta A logical value indicating whether to sample multivariate regression coefficients 
#' via Gibbs update from a Normal prior. Default is TRUE.
#' @param sample_theta_gibbs A logical value indicating whether to enable Gibbs sampling for the correlation 
#' parameters (\eqn{\theta}). This should be set to TRUE to run "IOX Grid" or "IOX Cluster" from the paper, otherwise FALSE.
#' @param update_theta A logical value indicating whether to update the correlation parameter options (\eqn{\theta}) 
#' adaptively during MCMC iterations. This should be set to TRUE to run "IOX Full" or "IOX Cluster" from the paper, otherwise FALSE.
#' The update is performed jointly for the whole vector if q=3 or less; conditionally in blocks if q>3.
#' @param num_threads An integer specifying the number of threads for parallel computation. Default is 1.
#' @param sampling An integer specifying how to sample the latent effects. Available options:  
#' sampling=1: block sampler for the entire set of latent effects (AVOID if \eqn{n} or \eqn{q} are large)
#' sampling=2 (default): single-outcome block sampler (\eqn{q} sequential steps)
#' sampling=3: single-site sampler (\eqn{n} sequential steps)
#'
#' @return A list containing:
#' \item{Beta}{Array of dimension (p,q,mcmc) with posterior samples of the regression coefficients (\eqn{\beta}).}
#' \item{Sigma}{Array of dimension (q,q,mcmc) with posterior samples of the covariance matrix (\eqn{\Sigma}).}
#' \item{theta}{Array of dimension (4,q,mcmc) with posterior samples of the correlation parameters (\eqn{\theta}).}
#' \item{theta_which}{Cluster membership for "IOX Grid" and "IOX Cluster".}
#' \item{theta_opts}{Cluster options for "IOX Grid" and "IOX Cluster".}
#' \item{W}{Array of dimension (n,q,mcmc) with posterior samples of the latent effects.}
#' \item{Ddiag}{Matrix of dimension (q, mcmc) with posterior samples of the diagonal of measurement error matrix D.}
#' \item{timings}{Breakdown of timings of the various MCMC operations (debugging).}
#'
#' @details The function is designed for scalable inference on spatial multivariate data using GP-IOX. 
#' Use multi-threading (`num_threads > 1`) for faster computation on large datasets.
#' How to set up `theta_opts`. Each column of theta has 4 elements. 1=phi, spatial decay parameter. 2=spatial variance. 3=smoothness or exponent. 4=nugget.
#' MCMC will sample the jth parameter a posteriori (j=1,2,3,4) ONLY if `var(theta_opts[j,])>0`. 
#' In other words, posterior sampling is DISABLED for parameter j if the entire jth row of `theta_opts` is set to the same value (which will be the fixed value of that parameter).
#' for "IOX Full", `theta_opts` should have \eqn{q} columns. For "IOX Cluster", `theta_opts` should have as many columns as the number of clusters (choose it smaller than \eqn{q}).
#' For "IOX Grid", `theta_opts` should have as many columns as the number of elements in the grid. Tested with up to 200 columns.
#' Beware that each column corresponds to a Vecchia-GP with `m` neighbors, so the memory footprint increases linearly with the number of columns of `theta_opts`.
#'
#' @export
spiox_latent <- function(Y, X, coords, custom_dag, theta_opts, Sigma_start, Beta_start, mcmc = 1000L, print_every = 100L, matern = 1L, dag_opts = 0L, sample_sigma = TRUE, sample_beta = TRUE, update_theta = TRUE, num_threads = 1L, sampling = 2L) {
    .Call(`_spiox_spiox_latent`, Y, X, coords, custom_dag, theta_opts, Sigma_start, Beta_start, mcmc, print_every, matern, dag_opts, sample_sigma, sample_beta, update_theta, num_threads, sampling)
}

spiox_response_vi <- function(Y, X, coords, custom_dag, dag_opts, theta, Sigma_start, Beta_start, verbose = 0L, matern = 1L, num_threads = 1L) {
    .Call(`_spiox_spiox_response_vi`, Y, X, coords, custom_dag, dag_opts, theta, Sigma_start, Beta_start, verbose, matern, num_threads)
}

spiox_response_map <- function(Y, X, coords, custom_dag, dag_opts, theta, Sigma_start, Beta_start, verbose = 0L, matern = 1L, num_threads = 1L) {
    .Call(`_spiox_spiox_response_map`, Y, X, coords, custom_dag, dag_opts, theta, Sigma_start, Beta_start, verbose, matern, num_threads)
}

spiox_predict <- function(X_new, coords_new, Y, X, coords, dag, B, Sigma, theta, matern = 1L, num_threads = 1L) {
    .Call(`_spiox_spiox_predict`, X_new, coords_new, Y, X, coords, dag, B, Sigma, theta, matern, num_threads)
}

spiox_predict_part <- function(Y_new, X_new, coords_new, Y, X, coords, dag, B, Sigma, theta, matern = 1L, num_threads = 1L) {
    .Call(`_spiox_spiox_predict_part`, Y_new, X_new, coords_new, Y, X, coords, dag, B, Sigma, theta, matern, num_threads)
}

spiox_latent_predict <- function(X_new, coords_new, coords, dag, W, B, Sigma, Dvec, theta, matern = 1L, num_threads = 1L) {
    .Call(`_spiox_spiox_latent_predict`, X_new, coords_new, coords, dag, W, B, Sigma, Dvec, theta, matern, num_threads)
}

